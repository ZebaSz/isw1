Object subclass: #ClassMapping	instanceVariableNames: 'mappedClass mappings tableName'	classVariableNames: ''	poolDictionaries: ''	category: 'IS1-CustomerImport-PersistanceModel'!!ClassMapping methodsFor: 'initialization' stamp: 'HernanWilkinson 10/31/2016 23:25'!initializeFor: aClass into: aTableName mappingAll: aCollectionOfMappings	mappedClass := aClass.	tableName := aTableName.	mappings := aCollectionOfMappings ! !!ClassMapping methodsFor: 'testing' stamp: 'HernanWilkinson 10/31/2016 23:02'!isFor: aClass	^mappedClass = aClass! !!ClassMapping methodsFor: 'table' stamp: 'HernanWilkinson 10/31/2016 23:25'!tableName		^tableName ! !!ClassMapping methodsFor: 'mapping' stamp: 'HernanWilkinson 11/1/2016 00:40'!map: anObject using: aDataBaseSession	| record |	self toDo: 'se puede optimizar usando array para registros y guardando definicion de tabla una vez'.	record := Dictionary new.		self mapIdOf: anObject into: record using: aDataBaseSession.	self mapEmbededOf: anObject into: record.	"agrego aca el registro y no luego de mapear el id para que lo agrege completo. Lo agrego antes de mapear las rel one to many 	porque si usuara una db de verdad habria foreign key constrain"	aDataBaseSession add: record on: self tableName.	self mapOneToManyRelationshipsOf: anObject using: aDataBaseSession! !!ClassMapping methodsFor: 'mapping' stamp: 'HernanWilkinson 11/1/2016 00:42'!unmap: aRecord using: aDataBaseSession	| unMappedObject |	unMappedObject := mappedClass basicNew.	self unmapIdOf: aRecord into: unMappedObject.	self unmap: aRecord into: unMappedObject using: aDataBaseSession.	^ unMappedObject! !!ClassMapping methodsFor: 'mapping - private' stamp: 'HernanWilkinson 11/1/2016 00:40'!mapEmbededOf: anObject into: record	mappings do: [ :aMapping | aMapping embeded: anObject into: record ]! !!ClassMapping methodsFor: 'mapping - private' stamp: 'HernanWilkinson 11/1/2016 00:40'!mapIdOf: anObject into: record using: aDataBaseSession	| newId |	newId := aDataBaseSession newIdFor: anObject.	anObject instVarNamed: #id put: newId.	record at: #id put: newId! !!ClassMapping methodsFor: 'mapping - private' stamp: 'HernanWilkinson 11/1/2016 00:43'!unmapIdOf: aRecord into: unMappedObject	unMappedObject instVarNamed: #id put: (aRecord at: #id)! !!ClassMapping methodsFor: 'mapping - private' stamp: 'HernanWilkinson 11/1/2016 00:40'!mapOneToManyRelationshipsOf: anObject using: aDataBaseSession	mappings do: [ :aMapping | aMapping mapOneToManyRelationshipsOf: anObject using: aDataBaseSession ]! !!ClassMapping methodsFor: 'mapping - private' stamp: 'HernanWilkinson 11/1/2016 00:43'!unmap: aRecord into: unMappedObject using: aDataBaseSession	mappings do: [ :aMapping | aMapping unmap: aRecord into: unMappedObject using: aDataBaseSession ]! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!ClassMapping class	instanceVariableNames: ''!!ClassMapping class methodsFor: 'instance creation' stamp: 'HernanWilkinson 10/31/2016 23:24'!for: aClass into: aTableName mappingAll: aCollectionOfMappings	self assertValidTableName: aTableName.	self assertHasIdInstanceVariable: aClass.	self assertValidMappings: aCollectionOfMappings for: aClass.		^self new initializeFor: aClass into: aTableName mappingAll: aCollectionOfMappings		! !!ClassMapping class methodsFor: 'instance creation' stamp: 'HernanWilkinson 10/31/2016 23:23'!withDefaultTableNameFor: aClass mappingAll: aCollectionOfMappings	^self for: aClass into: (self defaultTableNameFor: aClass) mappingAll: aCollectionOfMappings		! !!ClassMapping class methodsFor: 'instance creation' stamp: 'HernanWilkinson 11/1/2016 00:44'!defaultTableNameFor: aClass		^aClass name asString! !!ClassMapping class methodsFor: 'assertions' stamp: 'HernanWilkinson 10/31/2016 23:41'!assertValidTableName: aTableName	aTableName trimBoth isEmpty ifTrue: [ self error: 'Table name can not be empty' ]! !!ClassMapping class methodsFor: 'assertions' stamp: 'HernanWilkinson 10/31/2016 21:15'!assertHasIdInstanceVariable: aClass 		(aClass hasInstVarNamed: #id) ifFalse: [ self error: ('<1s> has no id instance variable' expandMacrosWith: aClass name) ]! !!ClassMapping class methodsFor: 'assertions' stamp: 'HernanWilkinson 10/31/2016 19:26'!assertValidMappings: aCollectionOfMappings for: aClass 	self toDo: 'Lo mejor seria recolectar todos los erroes de mapeo y no parar en el primero'.	aCollectionOfMappings do: [ :aMapping | aMapping assertIsValidFor: aClass ]	! !Object subclass: #DataBaseSession	instanceVariableNames: 'configuration tables id cache'	classVariableNames: ''	poolDictionaries: ''	category: 'IS1-CustomerImport-PersistanceModel'!!DataBaseSession methodsFor: 'selecting - private' stamp: 'HernanWilkinson 11/1/2016 01:28'!addInto: selected theOnesThatHold: aCondition unmapping: record with: mapper	| recordId aClassInstance |	recordId := self recordId: record.	aClassInstance := cache at: recordId ifAbsent: [ mapper unmap: record using: self ].	(aCondition value: aClassInstance) ifTrue: [ 		self addToCache: aClassInstance.		selected add: aClassInstance ].		^ selected! !!DataBaseSession methodsFor: 'initialization' stamp: 'HernanWilkinson 10/31/2016 22:55'!initializeFor: aConfiguration	configuration := aConfiguration.	id := 0.	tables := nil.	cache := nil.! !!DataBaseSession methodsFor: 'persistance' stamp: 'HernanWilkinson 11/1/2016 01:28'!persist: anObject	| mapper |		self assertInTransaction.	self delay.		mapper := self mapperFor: anObject class.	mapper map: anObject using: self.		self addToCache: anObject ! !!DataBaseSession methodsFor: 'id' stamp: 'HernanWilkinson 11/1/2016 01:00'!idOf: anObject	^anObject instVarNamed: #id! !!DataBaseSession methodsFor: 'id' stamp: 'HernanWilkinson 10/28/2016 16:35'!newIdFor: anObject	id := id + 1.	^id! !!DataBaseSession methodsFor: 'id' stamp: 'HernanWilkinson 11/1/2016 01:04'!recordId: aRecord	^aRecord at: #id! !!DataBaseSession methodsFor: 'selecting' stamp: 'HernanWilkinson 10/31/2016 22:17'!selectAllOfType: aClass 		^self select: [ :anObject | true ] ofType: aClass! !!DataBaseSession methodsFor: 'selecting' stamp: 'HernanWilkinson 11/1/2016 01:15'!objectIdentifiedAs: anId ofType: aClass	self assertInTransaction.	self delay.		^ cache at: anId ifAbsentPut: [ self unmapRecordIdentifiedAs: anId ofType: aClass ]! !!DataBaseSession methodsFor: 'selecting' stamp: 'HernanWilkinson 11/1/2016 01:26'!select: aCondition ofType: aClass	| mapper table |	self assertInTransaction.	self delay.		mapper := self mapperFor: aClass.	table := tables at: mapper tableName ifAbsent: [ ^ #() ].		^ table inject: OrderedCollection new into: [ :selected :record | self addInto: selected theOnesThatHold: aCondition unmapping: record with: mapper ]! !!DataBaseSession methodsFor: 'open/close' stamp: 'HernanWilkinson 10/31/2016 18:36'!assertIsOpen		tables isNil ifTrue: [ self error: 'Session must be open to colaborate with it' ]! !!DataBaseSession methodsFor: 'open/close' stamp: 'HernanWilkinson 11/4/2016 09:51'!start	self assertIsClose.		tables := Dictionary new.	! !!DataBaseSession methodsFor: 'open/close' stamp: 'HernanWilkinson 11/4/2016 09:52'!shutdown	self assertIsOpen.		tables := nil! !!DataBaseSession methodsFor: 'open/close' stamp: 'HernanWilkinson 10/31/2016 18:37'!assertIsClose		tables isNil ifFalse: [ self error: 'Session must be close' ]! !!DataBaseSession methodsFor: 'transaction management' stamp: 'HernanWilkinson 10/31/2016 22:57'!commit		self assertInTransaction.		cache := nil! !!DataBaseSession methodsFor: 'transaction management' stamp: 'HernanWilkinson 10/31/2016 22:55'!assertInTransaction		cache isNil ifTrue: [ self error: 'There is no transaction currently' ]! !!DataBaseSession methodsFor: 'transaction management' stamp: 'HernanWilkinson 10/31/2016 22:55'!assertNotInTransasction		cache notNil ifTrue: [ self error: 'There is an open transaction already' ]! !!DataBaseSession methodsFor: 'transaction management' stamp: 'HernanWilkinson 10/31/2016 22:57'!beginTransaction	self assertIsOpen.	self assertNotInTransasction.		cache := WeakKeyDictionary new.	! !!DataBaseSession methodsFor: 'adding - private' stamp: 'HernanWilkinson 11/1/2016 01:06'!relatedIdOwnedBy: anOwner on: table	^ table at: (self idOf: anOwner) ifAbsentPut: [ Set new ]! !!DataBaseSession methodsFor: 'adding - private' stamp: 'HernanWilkinson 11/1/2016 01:27'!addToCache: anObject 	cache at: (self idOf: anObject) put: anObject ! !!DataBaseSession methodsFor: 'adding - private' stamp: 'HernanWilkinson 11/1/2016 01:03'!add: aRecord on: aTableName	| table existingRecord |	table := self tableNamed: aTableName.	existingRecord := table at: (self recordId: aRecord) ifAbsentPut: [ aRecord ].	existingRecord == aRecord ifFalse: [ self error: 'Duplicated primary key' ]! !!DataBaseSession methodsFor: 'adding - private' stamp: 'HernanWilkinson 11/1/2016 01:03'!addRelated: aRelated ownedBy: anOwner	| relatedIds relatedId |	relatedIds := self relatedIdsOwnedBy: anOwner forType: aRelated class.	relatedId := aRelated instVarNamed: #id.	self assertRelationOwnedBy: anOwner isUniqueFor: aRelated identifiedAs: relatedId in: relatedIds.		relatedIds add: relatedId! !!DataBaseSession methodsFor: 'adding - private' stamp: 'HernanWilkinson 11/1/2016 01:10'!relatedIdsOwnedBy: anOwner forType: aRelatedClass	| relatedIds table |	table := self relationTableFor: anOwner class relatedTo: aRelatedClass.	relatedIds := self relatedIdOwnedBy: anOwner on: table.		^ relatedIds! !!DataBaseSession methodsFor: 'adding - private' stamp: 'HernanWilkinson 11/1/2016 01:00'!signalRelationAlreadyExistBetween: anOwner and: aRelated 	self error: ('Relation between id <1s> of type <2s> and id <3s> of type <4s> already exist'		expandMacrosWith: (self idOf: anOwner) printString		with: anOwner class name		with: (self idOf: aRelated) printString		with: aRelated class name)! !!DataBaseSession methodsFor: 'adding - private' stamp: 'HernanWilkinson 11/1/2016 01:05'!assertRelationOwnedBy: anOwner isUniqueFor: aRelated identifiedAs: relatedId in: relatedIds	(relatedIds includes: relatedId) ifTrue: [ self signalRelationAlreadyExistBetween: anOwner and: aRelated ]! !!DataBaseSession methodsFor: 'persistence - private' stamp: 'HernanWilkinson 10/28/2016 16:35'!defineIdOf: anObject	anObject instVarNamed: 'id' put: (self newIdFor: anObject).! !!DataBaseSession methodsFor: 'persistence - private' stamp: 'HernanWilkinson 10/28/2016 16:41'!delay	(Delay forMilliseconds: 100) wait! !!DataBaseSession methodsFor: 'mapping - private' stamp: 'HernanWilkinson 11/1/2016 01:15'!relatedOfType: aRelatedClass for: anOwner	| table relatedIds |		table := self relationTableFor: anOwner class relatedTo: aRelatedClass.	relatedIds := table at: (self idOf: anOwner) ifAbsent: [ ^#() ].		^relatedIds collect: [ :aRelatedId | self objectIdentifiedAs: aRelatedId ofType: aRelatedClass ]		! !!DataBaseSession methodsFor: 'mapping - private' stamp: 'HernanWilkinson 11/1/2016 01:16'!unmapRecordIdentifiedAs: anId ofType: aClass	| record table mapper |	mapper := self mapperFor: aClass.	table := self tableNamed: mapper tableName.	record := table at: id ifAbsent: [ self error: ('Object identified as <1s> does not exist' expandMacrosWith: anId printString) ].		^ mapper unmap: record using: self! !!DataBaseSession methodsFor: 'mapping - private' stamp: 'HernanWilkinson 11/1/2016 01:14'!mapperFor: aClass	self toDo: 'se puede mejorar performanco usando un dictionary'.	^configuration		detect: [ :aClassMapper | aClassMapper isFor: aClass ] 		ifNone: [ self error: ('There is no mapper for <1s>' expandMacrosWith: aClass name) ]! !!DataBaseSession methodsFor: 'tables - private' stamp: 'HernanWilkinson 11/1/2016 01:12'!relationTableNameOwnedBy: anOwnerClass relatedTo: aRelatedClass	| ownerClassMapper relatedClassMapper |		ownerClassMapper := self mapperFor: anOwnerClass.	relatedClassMapper := self mapperFor: aRelatedClass.		^ownerClassMapper tableName,'_', relatedClassMapper tableName asPlural.! !!DataBaseSession methodsFor: 'tables - private' stamp: 'HernanWilkinson 11/1/2016 01:12'!relationTableFor: anOwnerClass relatedTo: aRelatedClass	| relationTableName table |	relationTableName := self relationTableNameOwnedBy: anOwnerClass relatedTo: aRelatedClass.	table := self tableNamed: relationTableName.		^ table! !!DataBaseSession methodsFor: 'tables - private' stamp: 'HernanWilkinson 11/1/2016 00:48'!tableNamed: aTableName	^ tables at: aTableName ifAbsentPut: [ Dictionary new ]! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!DataBaseSession class	instanceVariableNames: ''!!DataBaseSession class methodsFor: 'instance creation' stamp: 'HernanWilkinson 10/28/2016 13:07'!for: aConfiguration	^self new initializeFor: aConfiguration! !Object subclass: #Mapping	instanceVariableNames: 'instanceVariableName'	classVariableNames: ''	poolDictionaries: ''	category: 'IS1-CustomerImport-PersistanceModel'!!Mapping methodsFor: 'mapping' stamp: 'HernanWilkinson 10/31/2016 23:26'!embeded: anObject into: aRecord	self subclassResponsibility! !!Mapping methodsFor: 'mapping' stamp: 'HernanWilkinson 10/31/2016 23:26'!mapOneToManyRelationshipsOf: anObject using: aDataBaseSession	self subclassResponsibility! !!Mapping methodsFor: 'mapping' stamp: 'HernanWilkinson 10/31/2016 23:26'!unmap: aRecord into: anObject using: aDataBaseSession	self subclassResponsibility! !!Mapping methodsFor: 'assertions' stamp: 'HernanWilkinson 11/1/2016 01:31'!assertIsValidFor: aClass 	(aClass hasInstVarNamed: instanceVariableName) ifFalse: [ 		self error: ('Invalid mapping for <1s> in class <2s>' expandMacrosWith: instanceVariableName with: aClass name) ] ! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!Mapping class	instanceVariableNames: ''!!Mapping class methodsFor: 'assertions' stamp: 'HernanWilkinson 10/31/2016 23:41'!assertValidFieldName: aFieldName	aFieldName trimBoth isEmpty ifTrue: [ self error: 'Field name can not be empty' ]! !!Mapping class methodsFor: 'instance creation' stamp: 'HernanWilkinson 11/1/2016 01:32'!defaultFieldNameFor: anInstanceVariableName	^anInstanceVariableName asString! !Mapping subclass: #EmbededMapping	instanceVariableNames: 'fieldName'	classVariableNames: ''	poolDictionaries: ''	category: 'IS1-CustomerImport-PersistanceModel'!!EmbededMapping methodsFor: 'initialization' stamp: 'HernanWilkinson 10/31/2016 23:30'!initializeFor: anInstanceVariableName into: aFieldName	instanceVariableName := anInstanceVariableName.	fieldName := aFieldName ! !!EmbededMapping methodsFor: 'mapping' stamp: 'HernanWilkinson 10/31/2016 23:31'!embeded: anObject into: aRecord	aRecord at: fieldName put: (anObject instVarNamed: instanceVariableName) ! !!EmbededMapping methodsFor: 'mapping' stamp: 'HernanWilkinson 10/31/2016 21:23'!mapOneToManyRelationshipsOf: anObject using: aDataBaseSession 		! !!EmbededMapping methodsFor: 'mapping' stamp: 'HernanWilkinson 10/31/2016 23:31'!unmap: aRecord into: anObject using: aDataBaseSession 	anObject instVarNamed: instanceVariableName put: (aRecord at: fieldName)! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!EmbededMapping class	instanceVariableNames: ''!!EmbededMapping class methodsFor: 'instance creation' stamp: 'HernanWilkinson 10/31/2016 23:30'!for: anInstanceVariableName into: aFieldName	^self new initializeFor: anInstanceVariableName into: aFieldName ! !!EmbededMapping class methodsFor: 'instance creation' stamp: 'HernanWilkinson 10/31/2016 23:29'!withDefaultFieldNameFor: anInstanceVariableName	^self for: anInstanceVariableName into: (self defaultFieldNameFor: anInstanceVariableName)! !Mapping subclass: #OneToManyMapping	instanceVariableNames: 'relatedType fieldName'	classVariableNames: ''	poolDictionaries: ''	category: 'IS1-CustomerImport-PersistanceModel'!!OneToManyMapping methodsFor: 'mapping' stamp: 'HernanWilkinson 10/31/2016 21:16'!embeded: anObject into: aRecord	! !!OneToManyMapping methodsFor: 'mapping' stamp: 'HernanWilkinson 11/1/2016 01:37'!mapOneToManyRelationshipsOf: anObject using: aDataBaseSession	| oldCollection newCollection |	newCollection := self createRelationCollectionOn: aDataBaseSession ownedBy: anObject.	oldCollection := anObject instVarNamed: instanceVariableName.		newCollection addAll: oldCollection.	anObject instVarNamed: instanceVariableName put: newCollection! !!OneToManyMapping methodsFor: 'mapping' stamp: 'HernanWilkinson 11/1/2016 01:37'!unmap: aRecord into: anObject using: aDataBaseSession	| newCollection related |	related := aDataBaseSession relatedOfType: relatedType for: anObject.	newCollection := self createRelationCollectionOn: aDataBaseSession ownedBy: anObject.	newCollection addAllNotPersisting: related.	anObject instVarNamed: instanceVariableName put: newCollection! !!OneToManyMapping methodsFor: 'mapping' stamp: 'HernanWilkinson 11/1/2016 01:35'!createRelationCollectionOn: aDataBaseSession ownedBy: anObject	^ OneToManySet on: aDataBaseSession ownedBy: anObject! !!OneToManyMapping methodsFor: 'initialization' stamp: 'HernanWilkinson 10/31/2016 23:34'!initializeFor: anInstanceVariableName into: aFieldName ofType: aClass	instanceVariableName := anInstanceVariableName.	fieldName := aFieldName.	relatedType := aClass ! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!OneToManyMapping class	instanceVariableNames: ''!!OneToManyMapping class methodsFor: 'instance creation' stamp: 'HernanWilkinson 10/31/2016 23:40'!for: anInstanceVariableName into: aFieldName ofType: aClass	self assertValidFieldName: aFieldName.		^self new initializeFor: anInstanceVariableName into: aFieldName ofType: aClass! !!OneToManyMapping class methodsFor: 'instance creation' stamp: 'HernanWilkinson 10/31/2016 23:32'!withDefaultFieldNameFor: anInstanceVariableName ofType: aClass	^self for: anInstanceVariableName into: (self defaultFieldNameFor: anInstanceVariableName) ofType: aClass! !Set subclass: #OneToManySet	instanceVariableNames: 'session owner'	classVariableNames: ''	poolDictionaries: ''	category: 'IS1-CustomerImport-PersistanceModel'!!OneToManySet methodsFor: 'adding' stamp: 'HernanWilkinson 11/1/2016 00:03'!addAllNotPersisting: aCollection 		^aCollection do: [ :anObjectToAdd | super add: anObjectToAdd ]! !!OneToManySet methodsFor: 'adding' stamp: 'HernanWilkinson 11/1/2016 00:11'!add: anObject	session persist: anObject.	session addRelated: anObject ownedBy: owner.		super add: anObject.! !!OneToManySet methodsFor: 'initialization' stamp: 'HernanWilkinson 11/1/2016 00:11'!initializeOn: aDataBaseSession ownedBy: anOwner		session := aDataBaseSession.	owner := anOwner ! !!OneToManySet methodsFor: 'removing' stamp: 'HernanWilkinson 10/31/2016 21:35'!remove: anObject ifAbsent: anAbsentBlock	self shouldBeImplemented ! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!OneToManySet class	instanceVariableNames: ''!!OneToManySet class methodsFor: 'instance creation' stamp: 'HernanWilkinson 11/1/2016 00:11'!on: aDataBaseSession ownedBy: anOwner		^self new initializeOn: aDataBaseSession ownedBy: anOwner ! !Object subclass: #Address	instanceVariableNames: 'id streetName streetNumber town zipCode province'	classVariableNames: ''	poolDictionaries: ''	category: 'IS1-CustomerImport-Model'!!Address methodsFor: 'testing' stamp: 'HernanWilkinson 11/1/2016 10:06'!isAt: aStreetName	^streetName = aStreetName ! !!Address methodsFor: 'street' stamp: 'HernanWilkinson 10/28/2016 13:27'!streetNumber: aStreetNumber 	streetNumber := aStreetNumber ! !!Address methodsFor: 'street' stamp: 'HernanWilkinson 10/28/2016 13:27'!streetName: aStreetName 	streetName := aStreetName ! !!Address methodsFor: 'street' stamp: 'HernanWilkinson 10/28/2016 16:12'!streetName	^streetName ! !!Address methodsFor: 'street' stamp: 'HernanWilkinson 10/28/2016 16:12'!streetNumber	^streetNumber ! !!Address methodsFor: 'zip code' stamp: 'HernanWilkinson 10/28/2016 16:08'!zipCode: aZipCode 	zipCode := aZipCode! !!Address methodsFor: 'zip code' stamp: 'HernanWilkinson 10/28/2016 16:13'!zipCode	^zipCode! !!Address methodsFor: 'province' stamp: 'HernanWilkinson 10/28/2016 16:11'!province	^province! !!Address methodsFor: 'province' stamp: 'HernanWilkinson 10/28/2016 16:08'!province: aProvince 	province := aProvince	! !!Address methodsFor: 'twon' stamp: 'HernanWilkinson 10/28/2016 16:07'!town: aTown 	town := aTown! !!Address methodsFor: 'twon' stamp: 'HernanWilkinson 10/28/2016 16:12'!town	^town! !TestCase subclass: #ERPImportTest	instanceVariableNames: 'importer system'	classVariableNames: ''	poolDictionaries: ''	category: 'IS1-CustomerImport-Model'!!ERPImportTest methodsFor: 'test data' stamp: 'HernanWilkinson 11/2/2016 15:52'!dataWithEmptyLine		^ ReadStream on: self alwaysImportedCustomerRecord,'A,San Martin,3322,Olivos,1636,BsAs'! !!ERPImportTest methodsFor: 'test data' stamp: 'SebastianSzperling 7/2/2018 15:09'!validCustomerTestData	^ ReadStream on: self alwaysImportedCustomerRecord,'A,San Martin,3322,Olivos,1636,BsAsA,Maipu,888,Florida,1122,Buenos AiresC,Juan,Perez,C,23-25666777-9A,Alem,1122,CABA,1001,CABA'! !!ERPImportTest methodsFor: 'importing' stamp: 'SebastianSzperling 7/2/2018 15:45'!importCustomersFrom: inputStream	(ERPImporter from: inputStream using: system) import! !!ERPImportTest methodsFor: 'importing' stamp: 'SebastianSzperling 7/2/2018 15:45'!importSuppliersFrom: inputStream	(ERPImporter from: inputStream using: system) import! !!ERPImportTest methodsFor: 'test data - supplier' stamp: 'SebastianSzperling 7/2/2018 16:50'!supplierWithMoreThanFourFieldsTestData		^ ReadStream on: self alwaysImportedSupplierRecord,',x'! !!ERPImportTest methodsFor: 'test data - supplier' stamp: 'SebastianSzperling 7/2/2018 15:11'!alwaysImportedSupplierRecord	^ 'S,Supplier1,',self alwaysImportedSupplierIdType,',',self alwaysImportedSupplierIdNumber.! !!ERPImportTest methodsFor: 'test data - supplier' stamp: 'SebastianSzperling 7/2/2018 16:31'!newCustomerWithoutSupplierTestData		^ ReadStream on: 'NC,Pepe,Sanchez,D,22333444'! !!ERPImportTest methodsFor: 'test data - supplier' stamp: 'SebastianSzperling 7/2/2018 15:11'!alwaysImportedSupplierIdType	^ 'D'! !!ERPImportTest methodsFor: 'test data - supplier' stamp: 'SebastianSzperling 7/2/2018 15:29'!validSupplierTestData	^ ReadStream on: self existingCustomerRecord, '', self alwaysImportedSupplierRecord,'NC,Pepe,Sanchez,D,22333444EC,D,5456774A,San Martin,3322,Olivos,1636,BsAsA,Maipu,888,Florida,1122,Buenos Aires'! !!ERPImportTest methodsFor: 'test data - supplier' stamp: 'SebastianSzperling 7/2/2018 16:39'!alwaysImportedSupplier	| anIdentificationNumber anIdentifycationType |	anIdentifycationType := self alwaysImportedSupplierIdType.	anIdentificationNumber := self alwaysImportedSupplierIdNumber.	^ system		supplierIdentifiedAs: anIdentifycationType		numbered: anIdentificationNumber! !!ERPImportTest methodsFor: 'test data - supplier' stamp: 'SebastianSzperling 7/2/2018 16:55'!newCustomerWithMoreThanFiveFieldsTestData		^ ReadStream on: self alwaysImportedSupplierRecord,'NC,Pepe,Sanchez,D,22333444,x'! !!ERPImportTest methodsFor: 'test data - supplier' stamp: 'SebastianSzperling 7/2/2018 16:20'!existingCustomerWithoutSupplierTestData		^ ReadStream on: 'EC,D,5456774'! !!ERPImportTest methodsFor: 'test data - supplier' stamp: 'SebastianSzperling 7/2/2018 15:11'!alwaysImportedSupplierIdNumber	^ '123'! !!ERPImportTest methodsFor: 'test data - supplier' stamp: 'SebastianSzperling 7/2/2018 16:33'!nonExistingCustomerTestData		^ ReadStream on: self alwaysImportedSupplierRecord,'EC,D,5456774'! !!ERPImportTest methodsFor: 'test data - supplier' stamp: 'SebastianSzperling 7/2/2018 16:57'!existingCustomerWithMoreThanThreeFieldsTestData	^ ReadStream on: self existingCustomerRecord, '', self alwaysImportedSupplierRecord,'EC,D,5456774,x'! !!ERPImportTest methodsFor: 'test data - supplier' stamp: 'SebastianSzperling 7/2/2018 15:30'!existingCustomerRecord	^ 'C,Juan,Palotes,D,5456774'! !!ERPImportTest methodsFor: 'setup-teardown' stamp: 'HernanWilkinson 11/4/2016 09:51'!setUp	system := Environment current createCustomerSystem.	system start.	system beginTransaction! !!ERPImportTest methodsFor: 'setup-teardown' stamp: 'HernanWilkinson 11/4/2016 09:52'!tearDown	system commit.	system shutdown! !!ERPImportTest methodsFor: 'testing' stamp: 'SebastianSzperling 7/2/2018 15:45'!testCanNotImportAddressWithoutCustomer	self		should: [ self importCustomersFrom: self addressWithoutCustomerTestData ]		raise: Error - MessageNotUnderstood		withExceptionDo: [ :anError | 			self				assert: anError messageText				equals: ERPImporter addressWithoutCustomerErrorDescription.			self assert: system customersIsEmpty ]! !!ERPImportTest methodsFor: 'testing' stamp: 'SebastianSzperling 7/2/2018 15:45'!testCanNotImportCustomerRecordWithLessThanFiveFields	self		should: [ self				importCustomersFrom: self customerRecordWithLessThanFiveFieldsTestData ]		raise: Error - MessageNotUnderstood		withExceptionDo: [ :anError | 			self				assert: anError messageText				equals: ERPImporter invalidCustomerRecordErrorDescription.			self assert: system customersIsEmpty ]! !!ERPImportTest methodsFor: 'testing' stamp: 'SebastianSzperling 7/2/2018 16:30'!testCanNotAddExistingCustomerWithoutSupplier	self		should: [ self importCustomersFrom: self existingCustomerWithoutSupplierTestData ]		raise: Error - MessageNotUnderstood		withExceptionDo: [ :anError | 			self				assert: anError messageText				equals: ERPImporter customerWithoutSupplierErrorDescription.			self assert: system customersIsEmpty.			self assert: system suppliersIsEmpty ]! !!ERPImportTest methodsFor: 'testing' stamp: 'SebastianSzperling 7/2/2018 15:13'!testImportSuppliers	self importSuppliersFrom: self validSupplierTestData.	self assertImportedSuppliersSizeIsCorrect.	self assertDefaultSupplierWasImportedCorrectly.! !!ERPImportTest methodsFor: 'testing' stamp: 'SebastianSzperling 7/2/2018 15:45'!testShouldNotImportCustomerRecordsStartingWithMoreThanC	self		should: [ self				importCustomersFrom: self customerRecordStartingWithMoreThanOneCTestData ]		raise: Error - MessageNotUnderstood		withExceptionDo: [ :anError | 			self				assert: anError messageText				equals: ERPImporter invalidRecordTypeErrorDescription.			self assert: system customersIsEmpty ]! !!ERPImportTest methodsFor: 'testing' stamp: 'SebastianSzperling 7/2/2018 15:09'!testImportCustomers	self importCustomersFrom: self validCustomerTestData.	self assertImportedCustomersSizeIsCorrect.	self assertPepeSanchezWasImportedCorrectly.	self assertJuanPerezWasImportedCorrectly! !!ERPImportTest methodsFor: 'testing' stamp: 'SebastianSzperling 7/2/2018 16:30'!testCanNotAddNewCustomerWithoutSupplier	self		should: [ self importCustomersFrom: self newCustomerWithoutSupplierTestData ]		raise: Error - MessageNotUnderstood		withExceptionDo: [ :anError | 			self				assert: anError messageText				equals: ERPImporter customerWithoutSupplierErrorDescription.			self assert: system customersIsEmpty.			self assert: system suppliersIsEmpty ]! !!ERPImportTest methodsFor: 'testing' stamp: 'SebastianSzperling 7/2/2018 16:38'!testCanNotAddNonExistingCustomer	self		should: [ self importCustomersFrom: self nonExistingCustomerTestData ]		raise: Error - MessageNotUnderstood		withExceptionDo: [ :anError | 			self				assert: anError messageText				equals: ERPImporter customerDoesNotExistErrorDescription.			self assert: system customersIsEmpty.			self assert: self alwaysImportedSupplier customersIsEmpty ]! !!ERPImportTest methodsFor: 'testing' stamp: 'SebastianSzperling 7/2/2018 15:45'!testCanNotImportAddressRecordWithLessThanSixFields		self		should: [ self importCustomersFrom: self addressRecordWithLessThanSixFieldsTestData ]		raise: Error - MessageNotUnderstood		withExceptionDo: [ :anError | 			self assert: anError messageText equals: ERPImporter invalidAddressRecordErrorDescription.			self assert: self alwaysImportedCustomer addressesIsEmpty ]! !!ERPImportTest methodsFor: 'testing' stamp: 'SebastianSzperling 7/2/2018 15:45'!testShouldNotImportAddressRecordsStartingWithMoreThanA	self 		should: [ self importCustomersFrom: self addressRecordStartingWithMoreThanOneATestData ]		raise: Error - MessageNotUnderstood 		withExceptionDo: [ :anError | 			self assert: anError messageText equals: ERPImporter invalidRecordTypeErrorDescription.			self assert: self alwaysImportedCustomer addressesIsEmpty ]	! !!ERPImportTest methodsFor: 'testing' stamp: 'SebastianSzperling 7/2/2018 16:56'!testCanNotImportNewCustomerRecordWithMoreThanFiveFields	self		should: [ self importCustomersFrom: self newCustomerWithMoreThanFiveFieldsTestData ]		raise: Error - MessageNotUnderstood		withExceptionDo: [ :anError | 			self				assert: anError messageText				equals: ERPImporter invalidCustomerRecordErrorDescription.			self assert: system customersIsEmpty.			self assert: self alwaysImportedSupplier customersIsEmpty ]! !!ERPImportTest methodsFor: 'testing' stamp: 'SebastianSzperling 7/2/2018 16:50'!testCanNotImportSupplierRecordWithMoreThanFourFields	self		should: [ self importCustomersFrom: self supplierWithMoreThanFourFieldsTestData ]		raise: Error - MessageNotUnderstood		withExceptionDo: [ :anError | 			self				assert: anError messageText				equals: ERPImporter invalidSupplierRecordErrorDescription.			self assert: system customersIsEmpty.			self assert: system suppliersIsEmpty ]! !!ERPImportTest methodsFor: 'testing' stamp: 'SebastianSzperling 7/2/2018 16:58'!testCanNotImportExistingCustomerRecordWithMoreThanThreeFields	self		should: [ self importCustomersFrom: self existingCustomerWithMoreThanThreeFieldsTestData ]		raise: Error - MessageNotUnderstood		withExceptionDo: [ :anError | 			self				assert: anError messageText				equals: ERPImporter invalidCustomerRecordErrorDescription.			self assert: self alwaysImportedSupplier customersIsEmpty ]! !!ERPImportTest methodsFor: 'testing' stamp: 'SebastianSzperling 7/2/2018 15:45'!testEmptyLinesAreRecognizedAsInvalidRecords		self		should: [ self importCustomersFrom: self dataWithEmptyLine ]		raise: Error - MessageNotUnderstood		withExceptionDo: [ :anError | 			self assert: anError messageText equals: ERPImporter invalidRecordTypeErrorDescription.			self assert: self alwaysImportedCustomer addressesIsEmpty ]! !!ERPImportTest methodsFor: 'testing' stamp: 'SebastianSzperling 7/2/2018 15:45'!testCanNotImportAddressRecordWithMoreThanSixFields	self 		should: [ self importCustomersFrom: self addressRecordWithMoreThanSixFieldsTestData ]		raise: Error - MessageNotUnderstood 		withExceptionDo: [ :anError | 			self assert: anError messageText equals: ERPImporter invalidAddressRecordErrorDescription.			self assert: self alwaysImportedCustomer addressesIsEmpty ]	! !!ERPImportTest methodsFor: 'testing' stamp: 'SebastianSzperling 7/2/2018 15:45'!testCanNotImportCustomerRecordWithMoreThanFiveFields	self		should: [ self				importCustomersFrom: self customerRecordWithMoreThanFiveFieldsTestData ]		raise: Error - MessageNotUnderstood		withExceptionDo: [ :anError | 			self				assert: anError messageText				equals: ERPImporter invalidCustomerRecordErrorDescription.			self assert: system customersIsEmpty ]! !!ERPImportTest methodsFor: 'test data - address' stamp: 'HernanWilkinson 11/2/2016 10:45'!addressRecordWithLessThanSixFieldsTestData		^ ReadStream on: self alwaysImportedCustomerRecord,'A,San Martin,3322,Olivos,1636'! !!ERPImportTest methodsFor: 'test data - address' stamp: 'HernanWilkinson 11/2/2016 10:45'!addressRecordWithMoreThanSixFieldsTestData		^ ReadStream on: self alwaysImportedCustomerRecord,'A,San Martin,3322,Olivos,1636,BsAs,y otra cosa'! !!ERPImportTest methodsFor: 'test data - address' stamp: 'HernanWilkinson 11/1/2016 15:59'!addressWithoutCustomerTestData		^ ReadStream on: 'A,San Martin,3322,Olivos,1636,BsAs'! !!ERPImportTest methodsFor: 'test data - address' stamp: 'HernanWilkinson 11/2/2016 10:45'!addressRecordStartingWithMoreThanOneATestData		^ ReadStream on: self alwaysImportedCustomerRecord,'AA,San Martin,3322,Olivos,1636,BsAs'! !!ERPImportTest methodsFor: 'asserting' stamp: 'HernanWilkinson 11/1/2016 11:00'!assert: customer hasAddressAt: streetName number: streetNumber in: town zipCode: zipCode province: province	| address |		address := customer addressAt: streetName ifNone: [ self fail ].	self assert: address streetName equals: streetName.	self assert: address streetNumber equals: streetNumber.	self assert: address town equals: town.	self assert: address zipCode equals: zipCode.	self assert: address province equals: province.	! !!ERPImportTest methodsFor: 'asserting' stamp: 'HernanWilkinson 11/3/2016 09:20'!assertPepeSanchezWasImportedCorrectly	| customer |	customer := self alwaysImportedCustomer. 		self assert: customer isNamed: 'Pepe' lastName: 'Sanchez' identfiedAs: self alwaysImportedCustomerIdType withNumber: self alwaysImportedCustomerIdNumber andNumberOfAddresses: 2.	self assert: customer hasAddressAt: 'San Martin' number: 3322 in: 'Olivos' zipCode: 1636 province: 'BsAs'.	self assert: customer hasAddressAt: 'Maipu' number: 888 in: 'Florida' zipCode: 1122 province: 'Buenos Aires'! !!ERPImportTest methodsFor: 'asserting' stamp: 'SebastianSzperling 7/2/2018 16:42'!assert: supplier isNamed: name identfiedAs: idType withNumber: idNumber andNumberOfAddresses: addressesSize andNumberOfCustomers: customersSize	self assert: supplier name equals: name.	self assert: supplier identificationType equals: idType.	self assert: supplier identificationNumber equals: idNumber.	self assert: supplier numberOfAddresses equals: addressesSize.	self assert: supplier numberOfCustomers equals: customersSize.! !!ERPImportTest methodsFor: 'asserting' stamp: 'HernanWilkinson 11/3/2016 09:10'!assertImportedCustomersSizeIsCorrect	self assert: system allCustomers size equals: 2! !!ERPImportTest methodsFor: 'asserting' stamp: 'SebastianSzperling 7/2/2018 15:56'!assert: supplier hasCustomerNamed: firstName lastName: lastName identfiedAs: idType withNumber: idNumber andNumberOfAddresses: addressesSize	| customer |	customer := supplier customerIdentifiedAs: idType numbered: idNumber ifNone: [ self fail ].	self assert: customer firstName equals: firstName.	self assert: customer lastName equals: lastName.	self assert: customer identificationType equals: idType.	self assert: customer identificationNumber equals: idNumber.	self assert: customer numberOfAddresses equals: addressesSize .! !!ERPImportTest methodsFor: 'asserting' stamp: 'HernanWilkinson 11/3/2016 09:21'!assertJuanPerezWasImportedCorrectly	| customer idType idNumber |	idType := 'C'.	idNumber := '23-25666777-9'.	customer := system customerIdentifiedAs: idType numbered: idNumber.	self		assert: customer		isNamed: 'Juan'		lastName: 'Perez'		identfiedAs: idType		withNumber: idNumber		andNumberOfAddresses: 1.	self		assert: customer		hasAddressAt: 'Alem'		number: 1122		in: 'CABA'		zipCode: 1001		province: 'CABA'! !!ERPImportTest methodsFor: 'asserting' stamp: 'SebastianSzperling 7/2/2018 16:41'!assertDefaultSupplierWasImportedCorrectly	| supplier |	supplier := self alwaysImportedSupplier.	self		assert: supplier		isNamed: 'Supplier1'		identfiedAs: self alwaysImportedSupplierIdType		withNumber: self alwaysImportedSupplierIdNumber		andNumberOfAddresses: 2		andNumberOfCustomers: 2.	self		assert: supplier		hasAddressAt: 'San Martin'		number: 3322		in: 'Olivos'		zipCode: 1636		province: 'BsAs'.	self		assert: supplier		hasAddressAt: 'Maipu'		number: 888		in: 'Florida'		zipCode: 1122		province: 'Buenos Aires'.			self		assert: supplier		hasCustomerNamed: 'Juan'		lastName: 'Palotes'		identfiedAs: 'D'		withNumber: '5456774'		andNumberOfAddresses: 0.	self		assert: supplier		hasCustomerNamed: 'Pepe'		lastName: 'Sanchez'		identfiedAs: 'D'		withNumber: '22333444'		andNumberOfAddresses: 0.! !!ERPImportTest methodsFor: 'asserting' stamp: 'HernanWilkinson 11/1/2016 10:56'!assert: customer isNamed: firstName lastName: lastName identfiedAs: idType withNumber: idNumber andNumberOfAddresses: addressesSize	self assert: customer firstName equals: firstName.	self assert: customer lastName equals: lastName.	self assert: customer identificationType equals: idType.	self assert: customer identificationNumber equals: idNumber.	self assert: customer numberOfAddresses equals: addressesSize .! !!ERPImportTest methodsFor: 'asserting' stamp: 'SebastianSzperling 7/2/2018 15:35'!assertImportedSuppliersSizeIsCorrect	self assert: system allSuppliers size equals: 1.! !!ERPImportTest methodsFor: 'test data - customer' stamp: 'HernanWilkinson 11/2/2016 10:46'!alwaysImportedCustomerIdType	^ 'D'! !!ERPImportTest methodsFor: 'test data - customer' stamp: 'HernanWilkinson 11/1/2016 17:48'!customerRecordStartingWithMoreThanOneCTestData		^ ReadStream on:'CC,Pepe,Sanchez,D,22333444'! !!ERPImportTest methodsFor: 'test data - customer' stamp: 'HernanWilkinson 11/3/2016 09:21'!alwaysImportedCustomer	| anIdentificationNumber anIdentifycationType |	anIdentifycationType := self alwaysImportedCustomerIdType.	anIdentificationNumber := self alwaysImportedCustomerIdNumber.	^ system		customerIdentifiedAs: anIdentifycationType		numbered: anIdentificationNumber! !!ERPImportTest methodsFor: 'test data - customer' stamp: 'HernanWilkinson 11/2/2016 10:47'!alwaysImportedCustomerRecord	^ 'C,Pepe,Sanchez,', self alwaysImportedCustomerIdType, ',', self alwaysImportedCustomerIdNumber ! !!ERPImportTest methodsFor: 'test data - customer' stamp: 'HernanWilkinson 11/2/2016 10:47'!alwaysImportedCustomerIdNumber	^ '22333444'! !!ERPImportTest methodsFor: 'test data - customer' stamp: 'HernanWilkinson 11/2/2016 10:53'!customerRecordWithMoreThanFiveFieldsTestData		^ ReadStream on: self alwaysImportedCustomerRecord,',x'! !!ERPImportTest methodsFor: 'test data - customer' stamp: 'HernanWilkinson 11/2/2016 10:50'!customerRecordWithLessThanFiveFieldsTestData		^ ReadStream on: 'C,Pepe,Sanchez,D'! !Object subclass: #ERPImporter	instanceVariableNames: 'line readStream record system newParty'	classVariableNames: ''	poolDictionaries: ''	category: 'IS1-CustomerImport-Model'!!ERPImporter methodsFor: 'importing - private - customer' stamp: 'HernanWilkinson 11/2/2016 10:55'!isCustomerRecord	^ record first = 'C'! !!ERPImporter methodsFor: 'importing - private - customer' stamp: 'SebastianSzperling 7/2/2018 15:15'!isExistingCustomerRecord	^ record first = 'EC'! !!ERPImporter methodsFor: 'importing - private - customer' stamp: 'HernanWilkinson 11/2/2016 10:57'!assertValidCustomerRecordSize		record size ~= 5 ifTrue: [ self signalInvalidCustomerRecord ].	! !!ERPImporter methodsFor: 'importing - private - customer' stamp: 'SebastianSzperling 7/2/2018 17:06'!importCustomer	self assertValidCustomerRecordSize.	newParty := Customer new.	newParty firstName: record second.	newParty lastName: record third.	newParty identificationType: record fourth.	newParty identificationNumber: record fifth.	system addCustomer: newParty! !!ERPImporter methodsFor: 'importing - private - customer' stamp: 'SebastianSzperling 7/2/2018 15:15'!isNewCustomerRecord	^ record first = 'NC'! !!ERPImporter methodsFor: 'importing - private - address' stamp: 'SebastianSzperling 7/2/2018 16:09'!assertThereIsCustsomerForAddress	newParty isNil ifTrue: [ self signalAddressWithoutCustomerError ].	! !!ERPImporter methodsFor: 'importing - private - address' stamp: 'HernanWilkinson 11/2/2016 10:57'!assertValidAddressRecordSize		record size ~= 6 ifTrue: [ self signalInvalidAddressRecord ].	! !!ERPImporter methodsFor: 'importing - private - address' stamp: 'HernanWilkinson 11/2/2016 10:55'!isAddressRecord	^ record first = 'A'! !!ERPImporter methodsFor: 'importing - private - address' stamp: 'SebastianSzperling 7/2/2018 16:09'!importAddress	| newAddress |	self assertThereIsCustsomerForAddress.	self assertValidAddressRecordSize.		newAddress := Address new.	newAddress streetName: record second.	newAddress streetNumber: record third asInteger.	newAddress town: record fourth.	newAddress zipCode: record fifth asInteger.	newAddress province: record sixth.	newParty addAddress: newAddress.! !!ERPImporter methodsFor: 'importing - private - address' stamp: 'SebastianSzperling 7/2/2018 16:08'!assertThereIsPartyForAddress	newParty isNil ifTrue: [ self signalAddressWithoutCustomerError ].	! !!ERPImporter methodsFor: 'importing - private' stamp: 'HernanWilkinson 11/2/2016 10:55'!canImportNextLine	line := readStream nextLine.	^ line notNil! !!ERPImporter methodsFor: 'importing - private' stamp: 'HernanWilkinson 11/2/2016 15:54'!convertLineToRecord	record := line substrings: {$,}.		self assertRecordNotEmpty! !!ERPImporter methodsFor: 'importing - private' stamp: 'SebastianSzperling 7/2/2018 15:21'!importRecord		self isCustomerRecord ifTrue: [ ^self importCustomer ].	self isAddressRecord ifTrue: [ ^self importAddress ].	self isSupplierRecord ifTrue: [ ^self importSupplier ].	self isNewCustomerRecord ifTrue: [ ^self importNewCustomer ].	self isExistingCustomerRecord ifTrue: [ ^self importExistingCustomer ].		self signalInvalidRecordType! !!ERPImporter methodsFor: 'importing - private' stamp: 'HernanWilkinson 11/2/2016 15:55'!assertRecordNotEmpty		record isEmpty ifTrue: [ self signalInvalidRecordType ]! !!ERPImporter methodsFor: 'initialization' stamp: 'HernanWilkinson 11/4/2016 09:26'!initializeOn: aReadStream using: aCustomerSystem	readStream := aReadStream.	system := aCustomerSystem! !!ERPImporter methodsFor: 'importing - private - supplier' stamp: 'SebastianSzperling 7/2/2018 16:51'!assertValidSupplierRecordSize		record size ~= 4 ifTrue: [ self signalInvalidSupplierRecord ].! !!ERPImporter methodsFor: 'importing - private - supplier' stamp: 'SebastianSzperling 7/2/2018 16:58'!importExistingCustomer	| customer |	self assertThereIsSupplierForCustomer.	self assertValidExistingCustomerRecordSize.	customer := system customerIdentifiedAs: record second numbered: record third ifNone: [ self signalCustomerDoesNotExist ].	newParty addCustomer: customer.! !!ERPImporter methodsFor: 'importing - private - supplier' stamp: 'SebastianSzperling 7/2/2018 17:06'!importNewCustomer	| customer |	self assertThereIsSupplierForCustomer.	self assertValidCustomerRecordSize.	customer := Customer new.	customer firstName: record second.	customer lastName: record third.	customer identificationType: record fourth.	customer identificationNumber: record fifth.	system addCustomer: customer.	newParty addCustomer: customer.! !!ERPImporter methodsFor: 'importing - private - supplier' stamp: 'SebastianSzperling 7/2/2018 16:29'!assertThereIsSupplierForCustomer	(newParty isKindOf: Supplier) ifFalse: [ self signalCustomerWithoutSupplier ].! !!ERPImporter methodsFor: 'importing - private - supplier' stamp: 'SebastianSzperling 7/2/2018 15:15'!isSupplierRecord	^ record first = 'S'! !!ERPImporter methodsFor: 'importing - private - supplier' stamp: 'SebastianSzperling 7/2/2018 16:58'!assertValidExistingCustomerRecordSize		record size ~= 3 ifTrue: [ self signalInvalidCustomerRecord ].! !!ERPImporter methodsFor: 'importing - private - supplier' stamp: 'SebastianSzperling 7/2/2018 16:53'!importSupplier	self assertValidSupplierRecordSize.	newParty := Supplier new.	newParty name: record second.	newParty identificationType: record third.	newParty identificationNumber: record fourth.	system addSupplier: newParty.! !!ERPImporter methodsFor: 'importing' stamp: 'HernanWilkinson 11/1/2016 17:51'!import	[ self canImportNextLine ] whileTrue: [ 		self convertLineToRecord.		self importRecord ]! !!ERPImporter methodsFor: 'error signal' stamp: 'SebastianSzperling 7/2/2018 16:27'!signalCustomerWithoutSupplier	self error: self class customerWithoutSupplierErrorDescription.! !!ERPImporter methodsFor: 'error signal' stamp: 'HernanWilkinson 11/2/2016 10:52'!signalInvalidCustomerRecord 		self error: self class invalidCustomerRecordErrorDescription ! !!ERPImporter methodsFor: 'error signal' stamp: 'HernanWilkinson 11/1/2016 17:54'!signalInvalidRecordType	self error: self class invalidRecordTypeErrorDescription! !!ERPImporter methodsFor: 'error signal' stamp: 'SebastianSzperling 7/2/2018 16:35'!signalCustomerDoesNotExist	self error: self class customerDoesNotExistErrorDescription.! !!ERPImporter methodsFor: 'error signal' stamp: 'SebastianSzperling 7/2/2018 16:51'!signalInvalidSupplierRecord 		self error: self class invalidSupplierRecordErrorDescription ! !!ERPImporter methodsFor: 'error signal' stamp: 'HernanWilkinson 11/1/2016 18:01'!signalInvalidAddressRecord 		self error: self class invalidAddressRecordErrorDescription ! !!ERPImporter methodsFor: 'error signal' stamp: 'HernanWilkinson 11/1/2016 16:01'!signalAddressWithoutCustomerError	self error: self class addressWithoutCustomerErrorDescription.! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!ERPImporter class	instanceVariableNames: ''!!ERPImporter class methodsFor: 'as yet unclassified' stamp: 'SebastianSzperling 7/2/2018 16:20'!customerWithoutSupplierErrorDescription	^'No supplier to add this customer to'.! !!ERPImporter class methodsFor: 'as yet unclassified' stamp: 'SebastianSzperling 7/2/2018 16:34'!customerDoesNotExistErrorDescription	^'No customer found with the requested id'.! !!ERPImporter class methodsFor: 'instance creation' stamp: 'HernanWilkinson 11/4/2016 09:27'!from: aReadStream using: aCustomerSystem	^ self new initializeOn: aReadStream using: aCustomerSystem! !!ERPImporter class methodsFor: 'error descriptions' stamp: 'HernanWilkinson 11/1/2016 17:54'!invalidRecordTypeErrorDescription		^'Invalid record type'! !!ERPImporter class methodsFor: 'error descriptions' stamp: 'HernanWilkinson 11/1/2016 16:02'!addressWithoutCustomerErrorDescription		^'There is no Customer for the imported address'! !!ERPImporter class methodsFor: 'error descriptions' stamp: 'HernanWilkinson 11/2/2016 10:51'!invalidCustomerRecordErrorDescription		^'Invalid customer record'! !!ERPImporter class methodsFor: 'error descriptions' stamp: 'HernanWilkinson 11/1/2016 18:00'!invalidAddressRecordErrorDescription		^'Invalid address record'! !!ERPImporter class methodsFor: 'error descriptions' stamp: 'SebastianSzperling 7/2/2018 16:52'!invalidSupplierRecordErrorDescription		^'Invalid supplier record'! !Object subclass: #ERPSystem	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'IS1-CustomerImport-Model'!!ERPSystem methodsFor: 'system live cycle' stamp: 'HernanWilkinson 11/4/2016 09:51'!start	self subclassResponsibility! !!ERPSystem methodsFor: 'system live cycle' stamp: 'HernanWilkinson 11/4/2016 09:52'!shutdown	self subclassResponsibility! !!ERPSystem methodsFor: 'transaction' stamp: 'HernanWilkinson 11/4/2016 09:35'!beginTransaction	self subclassResponsibility! !!ERPSystem methodsFor: 'transaction' stamp: 'HernanWilkinson 11/4/2016 09:35'!commit	self subclassResponsibility! !!ERPSystem methodsFor: 'suppliers' stamp: 'SebastianSzperling 7/2/2018 17:05'!supplierIdentifiedAs: anIdentifycationType numbered: anIdentificationNumber	self subclassResponsibility! !!ERPSystem methodsFor: 'suppliers' stamp: 'SebastianSzperling 7/2/2018 17:05'!addSupplier: aSupplier	self subclassResponsibility! !!ERPSystem methodsFor: 'suppliers' stamp: 'SebastianSzperling 7/2/2018 17:06'!suppliersIsEmpty	self subclassResponsibility! !!ERPSystem methodsFor: 'suppliers' stamp: 'SebastianSzperling 7/2/2018 17:05'!allSuppliers	self subclassResponsibility! !!ERPSystem methodsFor: 'suppliers' stamp: 'SebastianSzperling 7/2/2018 17:32'!supplierIdentifiedAs: anIdentifycationType numbered: anIdentificationNumber ifNone: noneBlock	self subclassResponsibility! !!ERPSystem methodsFor: 'customers' stamp: 'SebastianSzperling 7/2/2018 17:05'!addCustomer: aCustomer	self subclassResponsibility! !!ERPSystem methodsFor: 'customers' stamp: 'SebastianSzperling 7/2/2018 16:36'!customerIdentifiedAs: anIdentifycationType numbered: anIdentificationNumber ifNone: noneClosure 	self subclassResponsibility! !!ERPSystem methodsFor: 'customers' stamp: 'HernanWilkinson 11/4/2016 09:35'!customerIdentifiedAs: anIdentifycationType numbered: anIdentificationNumber	self subclassResponsibility! !!ERPSystem methodsFor: 'customers' stamp: 'HernanWilkinson 11/4/2016 09:35'!customersIsEmpty	self subclassResponsibility! !!ERPSystem methodsFor: 'customers' stamp: 'HernanWilkinson 11/4/2016 09:35'!allCustomers	self subclassResponsibility! !Object subclass: #Environment	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'IS1-CustomerImport-Model'!!Environment methodsFor: 'system creation' stamp: 'HernanWilkinson 11/4/2016 09:49'!createCustomerSystem	self subclassResponsibility ! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!Environment class	instanceVariableNames: ''!!Environment class methodsFor: 'enviroment selection' stamp: 'HernanWilkinson 11/4/2016 09:46'!current		^self allSubclasses 		detect: [ :anEnvironemntClass | anEnvironemntClass isCurrent ]		ifFound: [ :anEnvironmentClass | anEnvironmentClass new ]		ifNone: [ self error: 'No environment detected' ]! !!Environment class methodsFor: 'enviroment selection' stamp: 'HernanWilkinson 11/4/2016 09:49'!isCurrent	self subclassResponsibility ! !Environment subclass: #DevelpmentEnvironment	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'IS1-CustomerImport-Model'!!DevelpmentEnvironment methodsFor: 'system creation' stamp: 'SebastianSzperling 7/2/2018 15:31'!createCustomerSystem		^TransientERPSystem new! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!DevelpmentEnvironment class	instanceVariableNames: ''!!DevelpmentEnvironment class methodsFor: 'as yet unclassified' stamp: 'HernanWilkinson 11/4/2016 09:47'!isCurrent		^IntegrationEnvironment isCurrent not! !Environment subclass: #IntegrationEnvironment	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'IS1-CustomerImport-Model'!!IntegrationEnvironment methodsFor: 'system creation' stamp: 'SebastianSzperling 7/2/2018 15:31'!createCustomerSystem		^PersistentERPSystem new! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!IntegrationEnvironment class	instanceVariableNames: ''!!IntegrationEnvironment class methodsFor: 'testing' stamp: 'SebastianSzperling 7/2/2018 17:35'!isCurrent		^false! !Object subclass: #Party	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'IS1-CustomerImport-Model'!!Party methodsFor: 'addresses' stamp: 'SebastianSzperling 7/2/2018 17:17'!addAddress: anAddress 	self subclassResponsibility.! !!Party methodsFor: 'addresses' stamp: 'SebastianSzperling 7/2/2018 17:19'!numberOfAddresses		^self addresses size! !!Party methodsFor: 'addresses' stamp: 'SebastianSzperling 7/2/2018 17:17'!addressesIsEmpty		^self addresses isEmpty! !!Party methodsFor: 'addresses' stamp: 'SebastianSzperling 7/2/2018 17:17'!addressAt: aStreetName ifNone: noneClosure 		^self addresses detect: [ :anAddress | anAddress isAt: aStreetName ] ifNone: noneClosure ! !!Party methodsFor: 'addresses' stamp: 'SebastianSzperling 7/2/2018 17:17'!addresses	self subclassResponsibility.! !!Party methodsFor: 'identification' stamp: 'SebastianSzperling 7/2/2018 17:19'!isIdentifiedAs: anIdType numbered: anIdNumber 		^self identificationType = anIdType and: [ self identificationNumber = anIdNumber  ]! !!Party methodsFor: 'identification' stamp: 'SebastianSzperling 7/2/2018 17:18'!identificationNumber	self subclassResponsibility.! !!Party methodsFor: 'identification' stamp: 'SebastianSzperling 7/2/2018 17:18'!identificationNumber: anIdentificationNumber	self subclassResponsibility.! !!Party methodsFor: 'identification' stamp: 'SebastianSzperling 7/2/2018 17:18'!identificationType: anIdentificationType 	self subclassResponsibility.! !!Party methodsFor: 'identification' stamp: 'SebastianSzperling 7/2/2018 17:18'!identificationType	self subclassResponsibility.! !Party subclass: #Customer	instanceVariableNames: 'id firstName lastName addresses identificationType identificationNumber'	classVariableNames: ''	poolDictionaries: ''	category: 'IS1-CustomerImport-Model'!!Customer methodsFor: 'initialization' stamp: 'SebastianSzperling 7/2/2018 17:19'!initialize	addresses := OrderedCollection new.! !!Customer methodsFor: 'name' stamp: 'SebastianSzperling 7/2/2018 15:50'!lastName	^lastName ! !!Customer methodsFor: 'name' stamp: 'HernanWilkinson 10/28/2016 13:09'!lastName: aLastName 	lastName := aLastName! !!Customer methodsFor: 'name' stamp: 'HernanWilkinson 10/28/2016 16:15'!firstName		^firstName ! !!Customer methodsFor: 'name' stamp: 'HernanWilkinson 10/28/2016 13:09'!firstName: aName 	firstName := aName! !!Customer methodsFor: 'addresses' stamp: 'SebastianSzperling 7/2/2018 17:17'!addAddress: anAddress 	addresses add: anAddress ! !!Customer methodsFor: 'addresses' stamp: 'SebastianSzperling 7/2/2018 17:17'!addresses	^ addresses! !!Customer methodsFor: 'identification' stamp: 'SebastianSzperling 7/2/2018 17:18'!identificationNumber: anIdentificationNumber 	identificationNumber := anIdentificationNumber! !!Customer methodsFor: 'identification' stamp: 'SebastianSzperling 7/2/2018 17:18'!identificationType: anIdentificationType 	identificationType := anIdentificationType! !!Customer methodsFor: 'identification' stamp: 'SebastianSzperling 7/2/2018 17:18'!identificationType		^identificationType ! !!Customer methodsFor: 'identification' stamp: 'SebastianSzperling 7/2/2018 17:17'!identificationNumber		^identificationNumber ! !ERPSystem subclass: #PersistentERPSystem	instanceVariableNames: 'session'	classVariableNames: ''	poolDictionaries: ''	category: 'IS1-CustomerImport-Model'!!PersistentERPSystem methodsFor: 'suppliers' stamp: 'SebastianSzperling 7/2/2018 17:27'!suppliersIsEmpty	^ self allSuppliers isEmpty! !!PersistentERPSystem methodsFor: 'suppliers' stamp: 'SebastianSzperling 7/2/2018 17:20'!addSupplier: aSupplier	session persist: aSupplier.! !!PersistentERPSystem methodsFor: 'suppliers' stamp: 'SebastianSzperling 7/2/2018 17:26'!supplierIdentifiedAs: anIdentifycationType numbered: anIdentificationNumber	^self supplierIdentifiedAs: anIdentifycationType numbered: anIdentificationNumber ifNone: [ self error: 'No or more that one supplier found' ].! !!PersistentERPSystem methodsFor: 'suppliers' stamp: 'SebastianSzperling 7/2/2018 17:27'!allSuppliers	^ session selectAllOfType: Supplier! !!PersistentERPSystem methodsFor: 'suppliers' stamp: 'SebastianSzperling 7/2/2018 17:30'!supplierIdentifiedAs: anIdentifycationType numbered: anIdentificationNumber ifNone: noneBlock	| suppliers |	suppliers := session		select: [ :aSupplier | 			aSupplier identificationType = anIdentifycationType				and: [ aSupplier identificationNumber = anIdentificationNumber ] ]		ofType: Supplier.	suppliers size = 1		ifFalse: [noneBlock value].	^ suppliers anyOne! !!PersistentERPSystem methodsFor: 'mapping' stamp: 'HernanWilkinson 11/3/2016 08:52'!customerMapping	^ ClassMapping		withDefaultTableNameFor: Customer		mappingAll:			(Array				with: (EmbededMapping withDefaultFieldNameFor: #firstName)				with: (EmbededMapping withDefaultFieldNameFor: #lastName)				with: (EmbededMapping withDefaultFieldNameFor: #identificationType)				with: (EmbededMapping withDefaultFieldNameFor: #identificationNumber)				with: (OneToManyMapping withDefaultFieldNameFor: #addresses ofType: Address))! !!PersistentERPSystem methodsFor: 'mapping' stamp: 'SebastianSzperling 7/2/2018 17:21'!supplierMapping	^ ClassMapping		withDefaultTableNameFor: Supplier		mappingAll:			(Array				with: (EmbededMapping withDefaultFieldNameFor: #name)				with: (EmbededMapping withDefaultFieldNameFor: #identificationType)				with: (EmbededMapping withDefaultFieldNameFor: #identificationNumber)				with: (OneToManyMapping withDefaultFieldNameFor: #addresses ofType: Address)				with: (OneToManyMapping withDefaultFieldNameFor: #customers ofType: Customer))! !!PersistentERPSystem methodsFor: 'mapping' stamp: 'HernanWilkinson 11/3/2016 08:52'!addressMapping	^ ClassMapping		withDefaultTableNameFor: Address		mappingAll:			(Array				with: (EmbededMapping withDefaultFieldNameFor: #streetName)				with: (EmbededMapping withDefaultFieldNameFor: #streetNumber)				with: (EmbededMapping withDefaultFieldNameFor: #town)				with: (EmbededMapping withDefaultFieldNameFor: #zipCode)				with: (EmbededMapping withDefaultFieldNameFor: #province))! !!PersistentERPSystem methodsFor: 'transaction' stamp: 'HernanWilkinson 11/4/2016 09:18'!beginTransaction	session beginTransaction! !!PersistentERPSystem methodsFor: 'transaction' stamp: 'HernanWilkinson 11/4/2016 09:18'!commit	session commit! !!PersistentERPSystem methodsFor: 'system live cycle' stamp: 'HernanWilkinson 11/4/2016 09:51'!start	session start! !!PersistentERPSystem methodsFor: 'system live cycle' stamp: 'HernanWilkinson 11/4/2016 09:52'!shutdown	session shutdown! !!PersistentERPSystem methodsFor: 'initialization' stamp: 'HernanWilkinson 11/3/2016 08:54'!initialize		super initialize.	self initializeSession. ! !!PersistentERPSystem methodsFor: 'initialization' stamp: 'SebastianSzperling 7/2/2018 17:21'!initializeSession	session := DataBaseSession		for: (Array with: self addressMapping with: self customerMapping with: self supplierMapping)! !!PersistentERPSystem methodsFor: 'customers' stamp: 'SebastianSzperling 7/2/2018 17:23'!customerIdentifiedAs: anIdentifycationType numbered: anIdentificationNumber	^self customerIdentifiedAs: anIdentifycationType numbered: anIdentificationNumber ifNone: [ self error: 'No or more that one customer found' ].! !!PersistentERPSystem methodsFor: 'customers' stamp: 'SebastianSzperling 7/2/2018 17:06'!addCustomer: aCustomer	session persist: aCustomer! !!PersistentERPSystem methodsFor: 'customers' stamp: 'HernanWilkinson 11/3/2016 09:11'!customersIsEmpty	^ self allCustomers isEmpty! !!PersistentERPSystem methodsFor: 'customers' stamp: 'SebastianSzperling 7/2/2018 17:30'!customerIdentifiedAs: anIdentifycationType numbered: anIdentificationNumber ifNone: noneBlock	| customers |	customers := session		select: [ :aCustomer | 			aCustomer identificationType = anIdentifycationType				and: [ aCustomer identificationNumber = anIdentificationNumber ] ]		ofType: Customer.	customers size = 1		ifFalse: [noneBlock value].	^ customers anyOne! !!PersistentERPSystem methodsFor: 'customers' stamp: 'HernanWilkinson 11/4/2016 09:18'!allCustomers	^ session selectAllOfType: Customer! !Party subclass: #Supplier	instanceVariableNames: 'id name customers addresses identificationType identificationNumber'	classVariableNames: ''	poolDictionaries: ''	category: 'IS1-CustomerImport-Model'!!Supplier methodsFor: 'identification' stamp: 'SebastianSzperling 7/2/2018 17:18'!identificationNumber: anIdentificationNumber 	identificationNumber := anIdentificationNumber! !!Supplier methodsFor: 'identification' stamp: 'SebastianSzperling 7/2/2018 17:18'!identificationType: anIdentificationType 	identificationType := anIdentificationType! !!Supplier methodsFor: 'identification' stamp: 'SebastianSzperling 7/2/2018 17:18'!identificationType		^identificationType ! !!Supplier methodsFor: 'identification' stamp: 'SebastianSzperling 7/2/2018 17:17'!identificationNumber		^identificationNumber ! !!Supplier methodsFor: 'name' stamp: 'SebastianSzperling 7/2/2018 15:18'!name	^ name! !!Supplier methodsFor: 'name' stamp: 'SebastianSzperling 7/2/2018 15:17'!name: anObject	name := anObject! !!Supplier methodsFor: 'customers' stamp: 'SebastianSzperling 7/2/2018 15:22'!addCustomer: aCustomer 	customers add: aCustomer.! !!Supplier methodsFor: 'customers' stamp: 'SebastianSzperling 7/2/2018 15:59'!customerIdentifiedAs: anIdType numbered: anIdNumber ifNone: noneClosure 		^customers detect: [ :aCustomer | aCustomer isIdentifiedAs: anIdType numbered: anIdNumber ] ifNone: noneClosure.! !!Supplier methodsFor: 'customers' stamp: 'SebastianSzperling 7/2/2018 15:58'!customers	^ customers copy.! !!Supplier methodsFor: 'customers' stamp: 'SebastianSzperling 7/2/2018 16:42'!numberOfCustomers	^customers size.! !!Supplier methodsFor: 'customers' stamp: 'SebastianSzperling 7/2/2018 16:39'!customersIsEmpty	^customers isEmpty! !!Supplier methodsFor: 'addresses' stamp: 'SebastianSzperling 7/2/2018 17:17'!addAddress: anAddress 	addresses add: anAddress ! !!Supplier methodsFor: 'addresses' stamp: 'SebastianSzperling 7/2/2018 17:17'!addresses	^ addresses! !!Supplier methodsFor: 'initialization' stamp: 'SebastianSzperling 7/2/2018 17:19'!initialize	customers := OrderedCollection new.	addresses := OrderedCollection new.! !ERPSystem subclass: #TransientERPSystem	instanceVariableNames: 'customers suppliers'	classVariableNames: ''	poolDictionaries: ''	category: 'IS1-CustomerImport-Model'!!TransientERPSystem methodsFor: 'customers' stamp: 'SebastianSzperling 7/2/2018 15:33'!supplierIdentifiedAs: anIdentifycationType numbered: anIdentificationNumber		^suppliers detect: [ :aSupplier | aSupplier isIdentifiedAs: anIdentifycationType numbered: anIdentificationNumber ]! !!TransientERPSystem methodsFor: 'customers' stamp: 'SebastianSzperling 7/2/2018 17:03'!addCustomer: aCustomer	customers add: aCustomer! !!TransientERPSystem methodsFor: 'customers' stamp: 'SebastianSzperling 7/2/2018 16:37'!customerIdentifiedAs: anIdentifycationType numbered: anIdentificationNumber ifNone: noneBlock 	^customers detect: [ :aCustomer | aCustomer isIdentifiedAs: anIdentifycationType numbered: anIdentificationNumber ] ifNone: noneBlock.! !!TransientERPSystem methodsFor: 'customers' stamp: 'HernanWilkinson 11/4/2016 09:40'!customerIdentifiedAs: anIdentifycationType numbered: anIdentificationNumber		^customers detect: [ :aCustomer | aCustomer isIdentifiedAs: anIdentifycationType numbered: anIdentificationNumber ]! !!TransientERPSystem methodsFor: 'customers' stamp: 'HernanWilkinson 11/4/2016 09:40'!customersIsEmpty	^ customers isEmpty ! !!TransientERPSystem methodsFor: 'customers' stamp: 'HernanWilkinson 11/4/2016 09:39'!allCustomers	^ customers copy! !!TransientERPSystem methodsFor: 'system live cycle' stamp: 'HernanWilkinson 11/4/2016 09:51'!start	! !!TransientERPSystem methodsFor: 'system live cycle' stamp: 'HernanWilkinson 11/4/2016 09:52'!shutdown		! !!TransientERPSystem methodsFor: 'transaction' stamp: 'HernanWilkinson 11/4/2016 09:39'!beginTransaction		! !!TransientERPSystem methodsFor: 'transaction' stamp: 'HernanWilkinson 11/4/2016 09:39'!commit		! !!TransientERPSystem methodsFor: 'initialization' stamp: 'SebastianSzperling 7/2/2018 15:31'!initialize		customers := OrderedCollection new.	suppliers := OrderedCollection new.! !!TransientERPSystem methodsFor: 'suppliers' stamp: 'SebastianSzperling 7/2/2018 15:35'!allSuppliers	^suppliers copy.! !!TransientERPSystem methodsFor: 'suppliers' stamp: 'SebastianSzperling 7/2/2018 15:34'!addSupplier: aSupplier 	suppliers add: aSupplier.! !!TransientERPSystem methodsFor: 'suppliers' stamp: 'SebastianSzperling 7/2/2018 17:32'!supplierIdentifiedAs: anIdentifycationType numbered: anIdentificationNumber ifNone: noneBlock		^suppliers detect: [ :aSupplier | aSupplier isIdentifiedAs: anIdentifycationType numbered: anIdentificationNumber ] ifNone: noneBlock! !!TransientERPSystem methodsFor: 'suppliers' stamp: 'SebastianSzperling 7/2/2018 16:30'!suppliersIsEmpty	^suppliers isEmpty.! !'From Pharo6.0 of 13 May 2016 [Latest update: #60540] on 2 July 2018 at 5:46:27.209513 pm'!!String methodsFor: '*IS1-CustomerImport' stamp: 'HernanWilkinson 10/31/2016 23:57'!asPlural		^self last = $s 		ifTrue: [ self, 'es' ]		ifFalse: [ self, 's' ]! !'From Pharo6.0 of 13 May 2016 [Latest update: #60540] on 2 July 2018 at 5:46:27.210019 pm'!!Object methodsFor: '*IS1-CustomerImport' stamp: 'HernanWilkinson 10/31/2016 19:27'!toDo: aString 	! !